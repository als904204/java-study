## CAS(Compare-And-Swap)와 락(Lock) 방식의 비교**

**락(Lock) 방식**
비관적(pessimistic) 접근법
데이터에 접근하기 전에 항상 락을 획득
다른 스레드의 접근을 막음
"다른 스레드가 방해할 것이다"라고 가정

1줄 요약 : 멀티스레드를 싱글 스레드로 바꿔 한개 씩 실행

---

**CAS(Compare-And-Swap) 방식**
낙관적(optimistic) 접근법
락을 사용하지 않고 데이터에 바로 접근
충돌이 발생하면 그때 재시도
"대부분의 경우 충돌이 없을 것이다"라고 가정

1줄 요약 : 멀티 스레드 동시에 실행하여 실패하면 재시

---
정리하면 충돌이 많이 없는 경우에 CAS 연산이 빠른 것을 확인할 수 있다.
그럼 충돌이 많이 발생하지 않는 연산은 어떤 것이 있을까? 언제 CAS 연산을 사용하면 좋을까?
사실 간단한 CPU 연산은 너무 빨리 처리되기 때문에 충돌이 자주 발생하지 않는다. 충돌이 발생하기도 전에 이미 연산
을 완료하는 경우가 더 많다.

---

`BasicInteger` 의 실행 결과를 보면 최대한 스레드를 충돌하게 만들었는데도, 1000개 중에 약 50개의 스레드만 충
돌한 사실을 확인할 수 있다.
**락 방식**
스레드 충돌을 방지하기 위해 1000개의 스레드가 모두 락을 획득하고 반환하는 과정을 거친다.
락을 사용하기 때문에 1000개의 스레드는 순서대로 하나씩 수행된다.
사실 이 중에 스레드가 충돌하는 경우는 50개의 경우 뿐이다.
**CAS 방식**
1000개의 스레드를 모두 한 번에 실행한다.
그리고 충돌이 나는 50개의 경우만 재시도 한다.
이 예제는 억지로 충돌을 만들기 위해서 `sleep(10)` 을 넣었다. 만약 이 코드를 제거한다면 충돌 가능성은 100개 중
에 1개도 안될 것이다.
정리하면 간단한 CPU 연산에는 락 보다는 CAS를 사용하는 것이 효과적이다.

---

# 결론 
- 간단한 연산은 CAS 쓰자 (계속해서 반복하는데 간단한 연산은 CPU 가 금방 해결)
- 충돌이 자주 일어나고, 연산이 오래걸린다면 락을 쓰자. (충돌이 발생하여 재시도 하는데, 계속 재시도하면 너무 오래걸림)