`AtomicInteger` 가 제공하는 `incrementAndGet()`
코드도 앞서 우리가 직접 작성한 `incrementAndGet()`
코드와 똑같이 CAS를 활용하도록 작성되어 있다. CAS를 사용하면 락을 사용하지 않지만, 대신에 다른 스레드가 값을
먼저 증가해서 문제가 발생하는 경우 루프를 돌며 재시도를 하는 방식을 사용한다.
이 방식은 다음과 같이 동작한다
1. 현재 변수의 값을 읽어온다.
2. 변수의 값을 1 증가시킬 때, 원래 값이 같은지 확인한다. (CAS 연산 사용)
3. 동일하다면 증가된 값을 변수에 저장하고 종료한다.
4. 동일하지 않다면 다른 스레드가 값을 중간에 변경한 것이므로, 다시 처음으로 돌아가 위 과정을 반복한다.
   두 스레드가 동시에 실행되면서 문제가 발생하는 상황을 스레드가 충돌했다고 표현한다.
   이 과정에서 충돌이 발생할 때마다 반복해서 다시 시도하므로, 결과적으로 락 없이 데이터를 안전하게 변경할 수 있다.
   CAS를 사용하는 방식은 충돌이 드물게 발생하는 환경에서는 락을 사용하지 않으므로 높은 성능을 발휘할 수 있다. 이
   는 락을 사용하는 방식과 비교했을 때, 스레드가 락을 획득하기 위해 대기하지 않기 때문에 대기 시간과 오버헤드가 줄
   어드는 장점이 있다.
   그러나 충돌이 빈번하게 발생하는 환경에서는 성능에 문제가 될 수 있다. 여러 스레드가 자주 동시에 동일한 변수의 값
   을 변경하려고 시도할 때, CAS는 자주 실패하고 재시도해야 하므로 성능 저하가 발생할 수 있다. 이런 상황에서는 반복
   문을 계속 돌기 때문에 CPU 자원을 많이 소모하게 된다.
   **CAS(Compare-And-Swap)와 락(Lock) 방식의 비교**
   **락(Lock) 방식**
   비관적(pessimistic) 접근법
   데이터에 접근하기 전에 항상 락을 획득
   다른 스레드의 접근을 막음
   "다른 스레드가 방해할 것이다"라고 가정
   **CAS(Compare-And-Swap) 방식**
   낙관적(optimistic) 접근법
   락을 사용하지 않고 데이터에 바로 접근
   충돌이 발생하면 그때 재시도
   "대부분의 경우 충돌이 없을 것이다"라고 가정
   정리하면 충돌이 많이 없는 경우에 CAS 연산이 빠른 것을 확인할 수 있다.
   그럼 충돌이 많이 발생하지 않는 연산은 어떤 것이 있을까? 언제 CAS 연산을 사용하면 좋을까?
   사실 간단한 CPU 연산은 너무 빨리 처리되기 때문에 충돌이 자주 발생하지 않는다. 충돌이 발생하기도 전에 이미 연산
   을 완료하는 경우가 더 많다.
   앞서 여러 스레드가 `value++` 연산을 수행했던 `BasicInteger` , `VolatileInteger` 의 예를 보자.


- 실행결과
```java
BasicInteger result: 950
VolatileInteger result: 961
SyncInteger result: 1000
MyAtomicInteger result: 1000
```