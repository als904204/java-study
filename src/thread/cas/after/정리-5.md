# CAS
- 잠금 상태면 CPU가 while문을 돈다.
- 계속해서 락을 획득할 때 까지 검사한다
- 즉 간단한 연산이라 비즈니스 로직이 금방 끝난다면 좋으나, 오래걸리면 CPU를 갉아 먹는
- 오래 걸리는 비즈니스 로직은 Thread 락을 이용해, BLOCKED, WAITING상태인 락을 쓰는게 CPU에 . 좋


# 결론
정리
락 VS CAS 사용 방식
동기화 락(`synchronized` , `Lock(ReentrantLock)` )을 사용하는 방식과 CAS를 활용하는 락 프리 방식의 장단
점을 비교해보자.
**CAS의 장점**
1. 2. **낙관적 동기화**: 락을 걸지 않고도 값을 안전하게 업데이트할 수 있다. CAS는 충돌이 자주 발생하지 않을 것이라고
      가정한다. 이는 충돌이 적은 환경에서 높은 성능을 발휘한다.
      **락 프리(Lock-Free)**: CAS는 락을 사용하지 않기 때문에, 락을 획득하기 위해 대기하는 시간이 없다. 따라서 스
      레드가 블로킹되지 않으며, 병렬 처리가 더 효율적일 수 있다.
      **CAS의 단점**
1. **충돌이 빈번한 경우**: 여러 스레드가 동시에 동일한 변수에 접근하여 업데이트를 시도할 때 충돌이 발생할 수 있다.
   충돌이 발생하면 CAS는 루프를 돌며 재시도해야 하며, 이에 따라 CPU 자원을 계속 소모할 수 있다. 반복적인 재
   시도로 인해 오버헤드가 발생할 수 있다.
2. **스핀락과 유사한 오버헤드**: CAS는 충돌 시 반복적인 재시도를 하므로, 이 과정이 계속 반복되면 스핀락과 유사한
   성능 저하가 발생할 수 있다. 특히 충돌 빈도가 높을수록 이런 현상이 두드러진다.
   **동기화 락의 장점**
1. 2. 3. **충돌 관리**: 락을 사용하면 하나의 스레드만 리소스에 접근할 수 있으므로 충돌이 발생하지 않는다. 여러 스레드가
         경쟁할 경우에도 안정적으로 동작한다.
         **안정성**: 복잡한 상황에서도 락은 일관성 있는 동작을 보장한다.
         **스레드 대기**: 락을 대기하는 스레드는 CPU를 거의 사용하지 않는다.
         **동기화 락의 단점**
1. 2. **락 획득 대기 시간**: 스레드가 락을 획득하기 위해 대기해야 하므로, 대기 시간이 길어질 수 있다.
      **컨텍스트 스위칭 오버헤드**: 락을 사용하면, 락 획득을 대기하는 시점과 또 락을 획득하는 시점에 스레드의 상태가
      변경된다. 이때 컨텍스트 스위칭이 발생할 수 있으며, 이로 인해 오버헤드가 증가할 수 있다.
      **결론**
      일반적으로 동기화 락을 사용하고, 아주 특별한 경우에 한정해서 CAS를 사용해서 최적화해야 한다.
      CAS를 통한 최적화가 더 나은 경우는 스레드가 `RUNNABLE` `BLOCKED` , `WAITING` 상태에서 다시 `RUNNABLE` 상
      태로 가는 것 보다는, 스레드를 `RUNNABLE`
      로 살려둔 상태에서 계속 락 획득을 반복 체크하는 것이 더 효율적인 경우에
      사용해야 한다. 하지만 이 경우 대기하는 스레드가 CPU 자원을 계속 소모하기 때문에 대기 시간이 아주아주아주 짧아
      야 한다. 따라서 임계 영역이 필요는 하지만, 연산이 길지 않고 매우매우매우! 짧게 끝날 때 사용해야 한다.
      예를 들어 숫자 값의 증가, 자료 구조의 데이터 추가, 삭제와 같이 CPU 사이클이 금방 끝나지만 안전한 임계 영역, 또는
      원자적인 연산이 필요한 경우에 사용해야 한다.
      반면에 데이터베이스를 기다린다거나, 다른 서버의 요청을 기다리는 것 처럼 오래 기다리는 작업에 CAS를 사용하면
      CPU를 계속 사용하며 기다리는 최악의 결과가 나올 수도 있다. 이런 경우에는 동기화 락을 사용해야 한다.
      또한 CAS는 충돌 가능성이 낮은 환경에서 매우 효율적이지만, 충돌 가능성이 높은 환경에서는 성능 저하가 발생할 수
      있다. 이런 경우에는 상황에 맞는 적절한 동기화 전략을 사용하는 것이 중요하다. 때로는 락이 더 나은 성능을 발휘할 수